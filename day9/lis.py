# -*- coding: utf-8 -*-
"""
lis 最长递增子序列LIS
给定长度为N的数组A，计算A的最长的单调递增的子序列（不一定连续）
eg: 数组A[5,6,7,1,2,8]的LIS为[5,6,7,8],长度为4
day2里有一种解法
这里用动态规划做
算法：
O(n2)
    [1,4,6,2,8,9,7]
    用前缀分析：
    前缀             最长递增子序列
    1                1
    1,4              2
    1,4,6            3，把6排在[1,4]后边，能递增,所以用lis[1,4] + 1,递增子序列变成1,4,6
    1,4,6,2          2，把2排在[1,4,6]后边,不能递增了,所以最长递增子序列不变，还是3个数字。但定义要以2结尾，所以是1,2，为了后续好比较
    1,4,6,8          4，因为8比6大，可以和[1,4,6]构成递增序列，用lis[1,4,6] + 1
    1,4,6,8,9        5
    1,4,6,8,9,7      ???
    隐状态的定义

算法2
    O（nlogn）没看懂
    先做一个缓冲区[]
    1直接放进去是[1,]， 缓冲区长度是1
    4比1大，压入,[1,4], 缓冲区长度是2
    6比4大，压入，[1,4,6],缓冲区长度是3
    2比6小,2比4也小，2比1大，把缓冲区中的4变成2 [1,2,6]
    8比6大，缓冲区为[1,2,6,8]
    9 : [1,2,6,8,9]
    7比6大,比8小,把8换成7，缓冲区是[1,2,6,7,9],缓冲区长度为5
    于是通过缓冲区得到：
    [1,4,6,2,8,9,7]对应缓冲区
    [1,2,3,3,4,5,5],这个数字就是最长递增子序列的长度

    插入的复杂度是logN, 插入N次，所以是O(NlogN)
    本质:每次缓冲区的变化只和上一次缓冲区的状态有关系，所以这是一个贪心法
    求lis的时候，还是记录前驱


"""

__author__ = 'guyu'

def lis(A, size):
    longest = [0] * size
    for i in range(size):
        longest[i] = 1

    pre = [0] * size
    n_lis = 1
    for i in range(1, size):
        j = 0
        while j < i:
            # 比较A[i]和A[i]之前最大的数字, 如果A[i]大,那么longest[i] = 之前最大数字的递增子序列个数 + 1
            if A[j] <= A[i]:
                longest[i] = max(longest[i], longest[j]+1)
            j += 1
        n_lis = max(n_lis, longest[i])
    # print (pre)
    return n_lis


if __name__ == "__main__":
    A= [1,4,6,2,8,9,7]
    size = len(A)
    result = lis(A, size)
    print (result)

